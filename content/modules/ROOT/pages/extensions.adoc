= Quarkus Extensions
:experimental:
:imagesdir: images

## Explore Project

Let's take a look at the left *Explorer*. Your Quarkus project was already imported when the workspace was created. 

When you select the `pom.xml`, you will see which version of the IBM Enterprise Build of Quarkus you will use for the workshop today.

[source, xml]
----
    <properties>
        <compiler-plugin.version>3.14.0</compiler-plugin.version>
        <maven.compiler.release>21</maven.compiler.release>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
        <quarkus.platform.artifact-id>quarkus-bom</quarkus.platform.artifact-id>
        <quarkus.platform.group-id>com.redhat.quarkus.platform</quarkus.platform.group-id>
        <quarkus.platform.version>3.27.1.redhat-00003</quarkus.platform.version>
        <skipITs>true</skipITs>
        <surefire-plugin.version>3.5.3</surefire-plugin.version>
    </properties>
----

The project also has 

* The Maven structure
* An `org.acme.people.rest.GreetingResource` resource exposed on `/hello`, along with a simple test
* A landing page that is accessible on `http://localhost:8080` after starting the application
* The application configuration file
* Other source files we'll use later

Navigate to `src -> main -> java -> org.acme.people.rest` in the project tree and double select `GreetingResource.java`.

This class has a very simple RESTful endpoint definition:

[source, java]
----
@Path("/hello")
public class GreetingResource {

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello() {
        return "Hello from Quarkus REST";
    }
}
----

It’s a very simple REST endpoint, returning "hello" to requests on `/hello`.

[NOTE]
====
Compared to vanilla JAX-RS, with Quarkus there is no need to create an `Application` class. It’s supported but not required. In addition, only one instance of the resource is created and not one per request. You can configure this using the different *Scoped* annotations (`ApplicationScoped`, `RequestScoped`, etc).
====

## Running the Application in Quarkus Dev Mode for Living Code

**Live Coding** (also referred to as _Quarkus dev mode_) allows us to run the app and make changes on the fly. Quarkus will automatically re-compile and reload the app when changes are made. This is a powerful and efficient style of developing that you will use throughout the lab.

Before starting the dev mode, you need to *append* the following configuration to `application.properties` in the `src/main/resources` directory. This allows you to access the https://quarkus.io/guides/dev-ui[Dev UI^] from the cloud IDE since the Dev UI is designed for running your localhost.

[source, properties,role="copypaste",subs="attributes"]
----
%dev.quarkus.dev-ui.hosts={USER_ID}-quarkus-workshop-index-webpage.{ROUTE_SUBDOMAIN}
----

Note that the changes will be automatially saved in the IDE.

Open a new terminal windown on the VS Code.

image::new-terminal.png[commands, 600]

Run the following `mvn` (Maven) commands to run Quarkus dev mode in the terminal.

[source, shell,role="copypaste"]
----
mvn clean quarkus:dev -Dquarkus.http.host=0.0.0.0 -Dquarkus.analytics.disabled=true
----

When the dev mode starts, you will see a popup to access the *welcome* page.

image::cmd-livecoding.png[livecoding, 900]

*Leave this terminal window open throughout the lab!* You will complete the entire lab without shutting down Quarkus Live Coding mode, so be careful not to close the tab (if you do, you re-run it). This is very useful for quick experimentation.

[NOTE]
====
The first time you build the app, new dependencies may be downloaded via maven. This should only happen once, after that things will go even faster
====

[NOTE]
====
You may see WARNINGs like `Unrecognized configuration key` or `Duplicate entry`. These are configuration values that will take effect later on and can be safely ignored for now.
Occasionally you may get an error (e.g. `NullPointerException`) during Live Reloading. In this case, simply close the terminal and restart live coding using the task.
====

Note the amazingly fast startup time! The app is now running *locally* (within the VS Code container in which the workspace is also running). `localhost` refers to the Kubernetes pod, not *your* laptop (so therefore opening localhost:8080 in your browser will not do anything).

You can also see *Tests paused* by default when a Quarkus application gets started. We will learn more details in the _Testing Quarkus App_ lab.

When you select *Open In New Tab* to access the welcome page, you should see the popup message below. 

image::open-external.png[port, 700]

Select `Open`. A new tab in your web browser will open automatically.

image::welcome-quarkus.png[port, 900]

Select `/hello` enpoint on the Quarkus welcome. You should see the following page:

image::crw-open-page-hello.png[page, 800]

When you fail to access the *hello* endpoint URL, make sure if the new opened tab has the *http* protocol.

You can also test the endpoint using the _curl_ command. Open a *new* terminal by selecting `+` icon:

image::cmd-terminal.png[livecoding, 900]

Invoke the `hello` endpoint using the following _curl_ command:

[source,sh,role="copypaste"]
----
curl http://localhost:8080/hello
----

The output should look like this:

[source,sh]
----
Hello from Quarkus REST
----

Now, let's exercise the **live reload** capabilities of Quarkus. In VS Code, open the `GreetingResource.java` file in the *src/main/java/org/acme/people/rest* directory and change `return "Hello from Quarkus REST";` to `return "Hola from Quarkus REST";` in the editor. After making this change, reload the same brower tab that was showing `Hello from Quarkus REST`. It should now show `Hola from Quarkus REST`.

Wow, how cool is that? Supersonic Subatomic live reload! Go ahead and change it a few more times and access the endpoint again. And we're just getting started. Leave the app running so we can continue to change it on the fly in the next section.

[NOTE]
====
`quarkus:dev` runs Quarkus in development mode. This enables live reload with background compilation, which means that when you modify your Java files your resource files and refresh your browser these changes will automatically take effect.
====

[NOTE]
====
This will also listen for a debugger on port `5005`. If you want to wait for the debugger to attach before running you can pass `-Ddebug` on the command line. If you don’t want the debugger at all you can use `-Ddebug=false`. We'll use this later.
====

=== Login to OpenShift

Although your VS Code is running on the Kubernetes cluster, it's running with a default restricted _Service Account_ that prevents you from creating most resource types. So we'll log in with your workshop user. Execute the following command in the VS Code terminal:

[source,sh,role="copypaste",subs="attributes"]
----
oc login -u {USER_ID} -p {USER_PASSWORD} https://openshift.default.svc:443
----

You should see:

[source, none,subs="attributes"]
----
Login successful.

You have access to the following projects and can switch between them with 'oc project <projectname>':

  * {USER_ID}-devspaces
    {USER_ID}-project

Using project "user1-devspaces".
Welcome! See 'oc help' to get started.
----

Congratulations, you are now authenticated to the OpenShift server via the CLI. We'll use the prettier web console later on in this lab.

=== Deploy app

Deploy the `people` microservice by executing the following shell script in a CodeReady Workspaces Terminal:

[source, shell, role="copypaste",subs="attributes"]
----
sh scripts/deploy-people.sh {USER_ID}
----

Wait for the script to complete before continuing.

When the script completes, the app is deployed to OpenShift. You can see it in the https://console-openshift-console.{ROUTE_SUBDOMAIN}[OpenShift Console^]. Login with your assigned username and password (e.g. `{USER_ID}/{USER_PASSWORD}`):

image::che-login.png[login,700]

Once logged in, select the name of your project (`{USER_ID}-project`):

image::ocpproj.png[project,700]

In the sidebar menu, switch to the Topology View using the drop-down under Workloads:

image::devperspective.png[perspective, 500]

You can see the single `people` deployment that we just deployed earlier using the CLI:

image::peopledc.png[project,600]

[IMPORTANT]
====
You have to restore the following configuration to `application.properties` in the `src/main/resources` directory to access the Dev UI from the cloud IDE since the above bash script overwrote it.

[source, properties,role="copypaste",subs="attributes"]
----
%dev.quarkus.dev-ui.hosts={USER_ID}-quarkus-workshop-index-webpage.{ROUTE_SUBDOMAIN}
----
====

== List extensions

Ready to dive into *advanced* Quarkus development? Let's learn how easily Quarkus allows developers to extend for building a vibrant ecosystem.

Think of Quarkus extensions as your project dependencies. Extensions configure, boot and integrate a framework or technology into your Quarkus application. They also do all of the heavy lifting of providing the right information to GraalVM for your application to compile natively.

Quarkus aims to provide a support for a full https://quarkus.io/extensions/[extension ecosystem^], to make it easy to discover and consume 3rd party extensions, as well as providing easier version management.

Retrieve the list of possible extensions using the Maven plugin. Run this in the Terminal:

[source,sh,role="copypaste"]
----
mvn quarkus:list-extensions
----

You can see the list of ~538 different extensions available to you in the output:

[source,none]
----
[INFO] Current Quarkus extensions available: 
[INFO] 
[INFO] ✬ ArtifactId                                         Extension Name
[INFO] ✬ blaze-persistence-integration-quarkus              Blaze-Persistence
[INFO] ✬ camel-quarkus-activemq                             Camel ActiveMQ
[INFO] ✬ camel-quarkus-amqp                                 Camel AMQP
[INFO] ✬ camel-quarkus-arangodb                             Camel ArangoDb
[INFO] ✬ camel-quarkus-as2                                  Camel AS2
[INFO] ✬ camel-quarkus-atlasmap                             Camel AtlasMap
[INFO] ✬ camel-quarkus-atom                                 Camel Atom
[INFO] ✬ camel-quarkus-attachments                          Camel Attachments
[INFO] ✬ camel-quarkus-avro                                 Camel Avro
[INFO] ✬ camel-quarkus-avro-rpc                             Camel Avro RPC
[INFO] ✬ camel-quarkus-aws2-athena                          Camel AWS 2 Athena
[INFO] ✬ camel-quarkus-aws2-cw                              Camel AWS 2 CloudWatch
...
----

Adding an extension is similarly easy. With Maven, you can add extensions using `mvn quarkus:add-extension -Dextensions="extension1,extension2,..."`. The extension name can be the maven groupId/artifactId name of the extension: e.g. `io.quarkus:quarkus-agroal`. But you can pass a partial name and Quarkus will do its best to find the right extension. For example, `agroal`, `Agroal` or `agro` will expand to `io.quarkus:quarkus-agroal`. If no extension is found or if more than one extensions match, you will see a warning and a list of possible matches in the command result.

When you run Quarkus applications, the list of extensions enabled are shown in the output, such as:

[source, none]
----
INFO  [io.quarkus] (main) Installed features: [cdi, kubernetes, resteasy-reactive, smallrye-context-propagation, vertx]
----

[NOTE]
====
In Live Coding mode, Quarkus will monitor the state of `pom.xml` and bring in new dependencies. No need to stop and restart!
====

== Add an extension

Later on in this lab we'll be using `Jackson` serialization support for RESTEasy Reactive, so let's add that extension here. In the Terminal, run the following command to add the _RESTEasy Reactive Jackson_ extension to your project:

[source,sh,role="copypaste"]
----
mvn quarkus:add-extension -Dextensions="rest-jackson"
----

You should see
[source,console]
----
[INFO] [SUCCESS] ✅  Extension io.quarkus:quarkus-rest-jackson has been installed
----

The result of this command is a new `<dependency>` added to our `pom.xml` which you can see by looking at the differences you've made up till now.

Select the _Source Control_ view and then select `pom.xml`:

image::gitdiff.png[login,1000]

You'll see all the changes to `pom.xml` since you started, including the new extensions we've added.

You may see other apparent differences due to whitespace and/or the re-shuffling of XML elements when you ran `mvn quarkus:add-extension`.

There are many other git and GitHub operations like this one that you can perform directly in the IDE for real projects (e.g. committing, branching, merging, push/pull, log viewing, etc).

Go back to the **Explorer** view in CodeReady (to see the tree of files once again).

== Writing your own extension

Quarkus extensions add a new developer focused behavior to the core offering, and consist of two distinct parts, buildtime augmentation and runtime container. The augmentation part is responsible for all metadata processing, such as reading annotations, XML descriptors etc. The output of this augmentation phase is recorded bytecode which is responsible for directly instantiating the relevant runtime services.

This means that metadata is only processed once at build time, which both saves on startup time, and also on memory usage as the classes etc that are used for processing are not loaded (or even present) in the runtime JVM.

Writing a Quarkus extension is beyond the scope of this lab, so consult the https://quarkus.io/guides/extension-authors-guide[Extension Author's Guide^] for more detail on writing your own extension.

== Congratulations

Quarkus aims to provide a support for a full https://quarkus.io/extensions/[extension ecosystem^], to make it easy to discover and consume 3rd party extensions, as well as providing easier version management.

We'll be adding additional extensions as we go along in other sections of this workshop.
